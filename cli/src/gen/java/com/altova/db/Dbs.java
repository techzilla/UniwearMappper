/**
 * Dbs.java
 *
 * This file was generated by MapForce 2018r2sp1.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */

package com.altova.db;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.ResultSet;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import com.altova.mapforce.IEnumerable;
import com.altova.mapforce.IEnumerator;
import com.altova.mapforce.MFEmptySequence;
import com.altova.mapforce.MFSingletonSequence;
import com.altova.mapforce.SequenceFactory;

import com.altova.functions.Core;

import com.altova.types.CalendarBase;
import com.altova.types.DateTime;
import com.altova.types.Duration;
import com.altova.types.StringParseException;

public class Dbs 
{
	static class ForceOne implements IEnumerable
	{
		Object obj;
		
		public ForceOne(IEnumerable s) throws Exception
		{
			com.altova.mapforce.IEnumerator en = s.enumerator();
			try {
				if (en.moveNext()) 
					obj = en.current();
			} finally {
				en.close();
			}
		}

		static class InfiniteEnumerator implements com.altova.mapforce.IEnumerator
		{
			Object obj;
			int position;
			public InfiniteEnumerator(Object obj) { this.obj = obj; }
			public boolean moveNext() { ++position; return true; }
			public Object current() { return obj; }
			public int position() { return position; }
			public void close() {}
		}

		static class EmptyEnumerator implements com.altova.mapforce.IEnumerator
		{
			public EmptyEnumerator() {}
			public boolean moveNext() { return false; }
			public Object current() { return null; }
			public int position() { return 0; }
			public void close() {}
		}

		public com.altova.mapforce.IEnumerator enumerator() 
		{
			if (obj != null) return new InfiniteEnumerator(obj);
			else return new EmptyEnumerator();
		}
	}
	
	public static void writeField(Record record, String field, IEnumerable value) throws Exception
	{
		record.fields.put(field, new ForceOne(value));
	}
	
	static public void addChildren(Record record, String field, IEnumerable children)
	{
		record.children.put(field, children);
	}
	
	static public IEnumerable getChildren(Record record, String field)
	{
		return record.children.get(field);
	}
	
	public static IEnumerable readField(Record record, String name)
	{
		if (!record.fields.containsKey(name))
			throw new UnsupportedOperationException("Column \"" + name + "\" not found in record"); 
			
		return record.fields.get(name);
	}


	public static boolean checkForJdbcOdbcConnection( java.sql.Connection connection ) throws Exception
	{
	//	return (connection instanceof sun.jdbc.odbc.JdbcOdbcConnection);// not for linux
		return (connection.getClass().getName().equals("sun.jdbc.odbc.JdbcOdbcConnection"));
	}

	public static boolean checkForJdbcOdbcResultSet( java.sql.ResultSet resultSet ) throws Exception
	{
	//	return (resultSet instanceof sun.jdbc.odbc.JdbcOdbcResultSet);// not for linux
		return (resultSet.getClass().getName().equals("sun.jdbc.odbc.JdbcOdbcResultSet"));
	}
	
	private static int queryForOdbcMajorDriverVersion(java.sql.ResultSet resultSet) throws Exception
	{
		return queryForOdbcMajorDriverVersion(resultSet.getStatement().getConnection().getMetaData());
	}

	private static int queryForOdbcMajorDriverVersion(java.sql.DatabaseMetaData metaData) throws Exception
	{
		String driverVersion = metaData.getDriverVersion(); // e.g. for jdbcodbc "2.0001 (05.02.0004)"
		String odbcDriverVersion = driverVersion.substring(driverVersion.indexOf("(")+1, driverVersion.indexOf(")"));
		String odbcMajorVersion = odbcDriverVersion.substring(0, driverVersion.indexOf(".")+1);
		return Integer.parseInt(odbcMajorVersion);
	}

	static class ConnectionPool
	{
		private static final ConnectionPool instance = new ConnectionPool();
		public static ConnectionPool getInstance() { return instance; }		
		private java.util.HashMap<Integer, java.sql.Connection> map = new java.util.HashMap<Integer, java.sql.Connection>();
		protected ConnectionPool() {}// defeat instantiation.
		public java.sql.Connection newConnection(String url, String user, String password) throws Exception
		{
			java.util.Properties props = new java.util.Properties();
			props.put("user", user);
			props.put("password", password);
			props.put("CHARSET", "utf8");
			int hash = url.hashCode() ^ props.hashCode();
			if( map.containsKey(hash) ) {
				java.sql.Connection connection = map.get(hash);
				if(!connection.isClosed()) {
					return connection;
				}
			}
			java.sql.Connection connection = java.sql.DriverManager.getConnection(url, props);
			if(connection != null) map.put(hash, connection);
			return connection; 
		}

		public boolean hasConnection(java.sql.Connection connection) throws Exception
		{
			return map.containsValue(connection);
		}
		
		public void closeConnections() throws Exception
		{
			for( java.sql.Connection connection : map.values() ) {
				if(!connection.isClosed()) {
					connection.close();
				}
			}	

			map.clear();
		}
	}

	public static java.sql.Connection newConnection(String url, String user, String password) throws Exception
	{
		return ConnectionPool.getInstance().newConnection(url, user, password);
	}

	public static void closeConnection(java.sql.Connection connection) throws Exception
	{
		if(!ConnectionPool.getInstance().hasConnection(connection))
			connection.close();
	}
	
	public static void closeAllConnections() throws Exception
	{
		ConnectionPool.getInstance().closeConnections();
	}	
	
	public static void addParameter(Statement command, int type, int length)
	{
		command.addParameter(type, length);
	}
	
	public static void prepareStatement(Statement command)
	{
	}
	
	public static void storeStatement(Statement command)
	{
	}
	
	public static Statement newStatement(Catalog catalog, int id, String statement) throws Exception
	{
		statement = statement.trim();
		java.sql.DatabaseMetaData meta = catalog.getConnection().getMetaData(); 
		boolean stripSemicolon = meta.getDriverName().startsWith("IBM DB2 JDBC");
		if( stripSemicolon && statement.endsWith(";") ) 
		{// remove trailing statement end character (DB2: SQL0104N) 
			statement = statement.substring(0,statement.length()-1);
		}
		return catalog.createStatement(id, statement);
	}
	
	public static Statement newQuery(Catalog catalog, int id)
	{
		Statement statement = catalog.getStatement(id);
		statement.clear();
		return statement;
	}
	
	public static ResultSetWrapper executeQuery(Statement query) throws Exception
	{
		return query.execute();
	}

	public static int executeNonReader(Statement query) throws Exception
	{
		return query.executeNonReader();
	}
		
	static public Record newRecord()
	{
		return new Record();
	}
	
	static public boolean moveNextRecord(ResultSetWrapper recordset) throws Exception
	{
		return recordset.getResultSet().next();
	}
	
	static public void disposeRecordset(ResultSetWrapper recordset) throws Exception
	{
		recordset.close();
	}
	
	static public boolean isRecordsetClosed(ResultSetWrapper recordset) throws Exception
	{
		try
		{
			if(recordset != null && recordset.resultset != null)
			{
				return recordset.resultset.isClosed();
			}
			return true;
		}
		catch(java.lang.UnsupportedOperationException ex)
		{// from sun.jdbc.odbc.JdbcOdbcResultSet.isClosed
		}
		catch(java.lang.AbstractMethodError ex)
		{// from com.sybase.jdbc3.jdbc.SybResultSet.isClosed
		}
		return false;
	}
	
	public static void disposeQuery(Statement query) throws Exception
	{
		//query.close();
	}
	
	public static IEnumerable readRecordSet( ResultSetWrapper recordset, SequenceFactory lambda)
	{
		class TResult implements IEnumerable
		{
			class Enumerator implements IEnumerator
			{
				ResultSetWrapper recordset;
				SequenceFactory lambda;
				Object current;
				int pos;
				
				public Enumerator(ResultSetWrapper rs, SequenceFactory y)
				{
					recordset = rs;
					lambda = y;
				}
				
				public boolean moveNext() throws Exception 
				{
					if(recordset.resultset != null)
					{
						if(!isRecordsetClosed(recordset))
						{
							if(recordset.resultset.next())
							{
								current = Core.first((IEnumerable) lambda.invoke(recordset));
								pos++;
								return true;
							}
						}
					}
					return false;
				}
				
				public Object current() 
				{
					return current;
				}

				public int position() 
				{
					return pos;
				}

				public void close() 
				{
					try
					{
						if( recordset.resultset != null ){
							recordset.resultset.close();
							recordset.resultset = null;
						}
					}
					catch (Exception e)
					{
					}
				}
			}
			
			ResultSetWrapper recordset;
			SequenceFactory lambda;
			boolean firsttime = true;
			
			public TResult(ResultSetWrapper rs, SequenceFactory y)
			{
				recordset = rs;
				lambda = y;
			}

			public IEnumerator enumerator() throws Exception 
			{
				if(firsttime) { firsttime = false; return new Enumerator(recordset, lambda); }
				
				recordset.statement.prepare();
				recordset = recordset.statement.execute();
				return new Enumerator(recordset, lambda);
			}
		}
		
		return new TResult(recordset, lambda);
	}
	
	// KBFs
	
	public static void read_boolean(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object object = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Boolean value = null;
		if( object instanceof Boolean )
		{
			value = (Boolean) object;
		}
		else if( object instanceof String )
		{
			String s = (String)object;
			boolean b = s.equalsIgnoreCase("true")
					||	s.equalsIgnoreCase("yes")
					||	s.equalsIgnoreCase("1");
			value = Boolean.valueOf(b);
		}

		record.fields.put(name, new MFSingletonSequence(value.booleanValue()));
	}
	
	public static void read_byte(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object object = recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		int intValue = 0;
		if( object instanceof Number )
			intValue = ((Number)object).intValue();
		else
		if( object instanceof Boolean )
			intValue = ((Boolean)object) ? 1 : 0;

		record.fields.put(name, new MFSingletonSequence(intValue));
	}
	
	public static void read_short(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.ResultSet resultSet = recordset.getResultSet(); 
		Object value = resultSet.getObject(column+1);

		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}

		if( value instanceof Number )
		{
			record.fields.put(name, new MFSingletonSequence(((Number)value).intValue()));
			return;
		}
		if( value instanceof java.util.Date )
		{
			Long year = MySQL.internal_read_year( resultSet, column, (java.util.Date)value );
			record.fields.put(name, new MFSingletonSequence( year.intValue() ));
			return;
		}
		
		// error
	}
	
	public static void read_int(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.intValue()));
	}
	
	public static void read_long(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull() || value == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.longValue()));
	}
	
	public static void read_float(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		// MapForce strictly uses type double for internal operations
		record.fields.put(name, new MFSingletonSequence(value.doubleValue()));
	}
	
	public static void read_double(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value.doubleValue()));
	}
	
	public static void read_BigDecimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Number value = (Number) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		BigDecimal numeric = null;
		if( value instanceof BigDecimal ) { numeric = (BigDecimal)(value); }
		else { numeric = new BigDecimal( value.doubleValue() ); }
		record.fields.put(name, new MFSingletonSequence(numeric));
	}
	
	public static void read_BigInteger(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		BigInteger value = (BigInteger) recordset.getResultSet().getObject(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_Date(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_DateTime(record, recordset, name, column);
	}
	
	public static void read_DateTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		Object obj = recordset.getResultSet().getObject(column+1);
		
		if ((obj == null) || (recordset.getResultSet().wasNull()))
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = null;
		
		if (obj instanceof java.sql.Timestamp)
			value = timestampToDateTime((java.sql.Timestamp)obj);
			
		if(obj instanceof java.sql.Date)
			value = timestampToDateTime((java.sql.Date) obj);
		
		if(obj instanceof java.sql.Time)
			value = timestampToDateTime((java.sql.Time) obj);
		
		if(obj instanceof java.lang.String)
			value = DateTime.parse((java.lang.String) obj);
		
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_Clob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		java.sql.Clob clob = recordset.getResultSet().getClob(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		String str = clob.getSubString(0, (int)clob.length());
		record.fields.put(name, new MFSingletonSequence(str));
	}
	
	public static void read_binary(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(column+1);
		
		if (recordset.getResultSet().wasNull() || blob == null) 
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		record.fields.put(name, new MFSingletonSequence(blob));
	}
	
	public static void read_blob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		read_binary(record, recordset, name, column);
	}
	
	public static void read_String_ParseDate(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();
		value.parseDate(str.trim());
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
				
		DateTime value = new DateTime();// 24:00:00 = 00:00:00
		value.parseDateTime(str.trim(),DateTime.DateTimePart_Time);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseDateTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		DateTime value = new DateTime();
		value.parseDateTime(str.trim(), CalendarBase.DateTimePart_Date | CalendarBase.DateTimePart_Time);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseDecimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		str = str.trim(); // remove any whitespaces
		if( !str.contains("e") || !str.contains("E") )
		{// for non-scientific formatted decimal.
			if( str.contains(".") )
			{// right trim any trailing zeroes and the decimal dot.
				while( (str.length() > 0) && (str.endsWith("0")) )
					str = str.substring(0, str.length()-1);
				if( (str.length() > 0) && (str.endsWith(".")) )
					str = str.substring(0, str.length()-1);
			}
		}
		
		BigDecimal value = new BigDecimal(str);
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseDouble(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Double value = new Double(str.trim());
		record.fields.put(name, new MFSingletonSequence(value));
	}
	
	public static void read_String_ParseIntervalYearToMonth(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0);
		str = str.trim(); // strip leading/trailing whitespaces
		CalendarBase.ParseContext context = new Duration.ParseContext(str);
		String err = str + " cannot be converted to a duration value.";
		
		boolean positive = true; // parse sign
		if( context.checkAndAdvance('-') ) positive = false;
		else if( context.checkAndAdvance('+') ) positive = true;
		//else throw new StringParseException(err + "Invalid or missing sign.",2);
		if (!context.isValid()) throw new StringParseException(err,2);
		
		int years = 0; // parse year component
		while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }
		
		// check year-month divider
		if (!context.isValid()) throw new StringParseException(err + "Missing year-month divider.",2);
		if (!context.checkAndAdvance('-')) throw new StringParseException(err + "Invalid year-month divider.",2);
		if (!context.isValid()) throw new StringParseException(err + "Missing month value.",2);
		
		int month = 0;// parse month component
		while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
		
		Duration duration = new Duration(years, month, 0, 0, 0, 0, 0.0, !positive );
		record.fields.put(name, new MFSingletonSequence(duration));
	}
	
	
	public static void read_String_ParseIntervalDayToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String str = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		Duration.RefInt n = new Duration.RefInt(0); 
		str = str.trim(); // strip leading/trailing whitespaces
		CalendarBase.ParseContext context = new Duration.ParseContext(str);
		String err = str + " cannot be converted to a duration value.";
		
		boolean positive = true; // parse sign
		if( context.checkAndAdvance('-') ) positive = false;
		else if( context.checkAndAdvance('+') ) positive = true;
		//else throw new StringParseException(err,2);
		if (!context.isValid()) throw new StringParseException(err,2);
		
		int days = 0; // parse day component
		while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
		if (!context.isValid()) throw new StringParseException(err,2);
		
		// check days-time divider
		if (!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
		if (!context.isValid()) throw new StringParseException(err,2);
		
		String isotime = str.substring( context.index() );// parse hours:minutes:seconds.fraction 
		DateTime time = new DateTime();
		time.parseTime(isotime);
		
		Duration duration = new Duration(0, 0, days, time.getHour(), time.getMinute(), time.getSecond(), time.getMillisecond()/1000.0, !positive );
		record.fields.put(name, new MFSingletonSequence(duration));
	}
	
	private static String internalFormatGUID(byte[] bytes)
	{	
		if( (bytes == null) || ((bytes != null) && bytes.length == 0) ) 
			return null; // sanity check
		
		byte[] hexchars = {
			'0', '1', '2', '3', '4', '5',
			'6', '7', '8', '9', 'a', 'b',
			'c', 'd', 'e', 'f'
		};
		Boolean curly = true;
		int n = (2 * bytes.length) + 4 + (curly ? 2 : 0);
		StringBuilder s = new StringBuilder(n);
		if( curly ) s.append('{');//prefix
		for (int i = 0; i < bytes.length; i++) 
		{
			int v = bytes[i] & 0xff;
			s.append((char)hexchars[v >> 4]);
			s.append((char)hexchars[v & 0xf]);
			if( i==3 || i==5 || i==7 || i==9)
				s.append('-');//separator 
		}
		if( curly ) s.append('}');//suffix
		return s.toString().toUpperCase();			
	}
	
	public static void read_binary_Guid(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		byte[] blob = recordset.getResultSet().getBytes(column+1);
		
		if (recordset.getResultSet().wasNull() || blob == null)
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		
		byte[] buf = new byte[8];
		
		buf[0] = blob[3];	buf[1] = blob[2];	buf[2] = blob[1];	buf[3] = blob[0];
		buf[4] = blob[5];	buf[5] = blob[4];	buf[6] = blob[7];	buf[7] = blob[6];

		blob[0] = buf[0];	blob[1] = buf[1];	blob[2] = buf[2];	blob[3] = buf[3];
		blob[4] = buf[4];	blob[5] = buf[5];	blob[6] = buf[6];	blob[7] = buf[7];

		String value = internalFormatGUID( blob );
		record.fields.put(name, new MFSingletonSequence(value));
	}

	public static void read_string_Guid(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
	{
		String value = recordset.getResultSet().getString(column+1);
		
		if (recordset.getResultSet().wasNull())
		{
			record.fields.put(name, new MFEmptySequence());
			return;
		}
		if( !value.startsWith("{")) value = "{" + value;
		if( !value.endsWith("}")) value = value + "}";
		record.fields.put(name, new MFSingletonSequence(value.toUpperCase()));
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, int column, String charsetName ) throws Exception
	{
		return internal_read_unicodestring( resultSet, column, java.nio.charset.Charset.forName(charsetName) );
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, int column, java.nio.charset.Charset charset ) throws Exception
	{
		java.io.InputStream stream = resultSet.getBinaryStream(column+1);
		java.io.InputStreamReader reader = (stream != null) ? new java.io.InputStreamReader(stream,charset) : null;
		return internal_read_unicodestring( resultSet, reader );
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, java.io.InputStream stream ) throws Exception
	{
		java.io.InputStreamReader reader = (stream != null) ? new java.io.InputStreamReader(stream) : null;
		return internal_read_unicodestring( resultSet, reader );
	}
	
	private static String internal_read_unicodestring( java.sql.ResultSet resultSet, java.io.Reader reader ) throws Exception
	{
		String content = null;
		if( reader != null )
		{
			java.io.StringWriter writer = new java.io.StringWriter();
			
			int v,n;//build graphic string, count size
			for( n=0; (v = reader.read()) != -1; ++n )
				writer.write(v);

			writer.flush();// finalize writer
			
			if( !(resultSet.wasNull()) && (n == 0) )
			{// value is an empty string
				content = new String("");  
			}
			else
			if( !(resultSet.wasNull()) && (n > 0))  
			{
				content = writer.toString();
			}
		}
		
		return content;
	}
	
	// Helper functions
	
	private static com.altova.types.DateTime timestampToDateTime(java.util.Date ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		return new com.altova.types.DateTime(cal);
	}
	
	private static com.altova.types.DateTime timestampToDateTime(java.sql.Time ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		return new com.altova.types.DateTime(cal);
	}
	
	private static com.altova.types.DateTime timestampToDateTime(java.sql.Timestamp ts)
	{
		if (ts == null)
			return null;
			
		java.util.Calendar cal = java.util.Calendar.getInstance();
		cal.setTimeInMillis(ts.getTime());
		com.altova.types.DateTime val = new com.altova.types.DateTime(cal);
		val.setPartSecond( ts.getNanos() / 1000000000.0 );
		return val; 
	}
	
	// parameter binding
	
	public static void bindParameter_empty(Statement command)
	{
		command.bindParameter(null);
	}
	
	public static void bindParameter_String(Statement command, String value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigDecimal(Statement command, BigDecimal value) throws Exception
	{
		command.bindParameter(value, value.scale());
	}
	
	public static void bindParameter_DateTime(Statement command, DateTime value) throws Exception
	{
		value.setTimezoneOffset(0);// cut off tz
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		long millisec = value.getValue().getTimeInMillis();
		java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
		ts.setTime( ts.getTime() - tzoffset );// cut local tz
		ts.setNanos((int)(value.getPartSecond() * 1000000000));
		command.bindParameter(ts);
	}
	
	public static void bindParameter_DateTimeTZ(Statement command, DateTime value) throws Exception
	{
		long millisec = value.getValue().getTimeInMillis();
		java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
		command.bindParameter(ts);
	}
	
	public static void bindParameter_Time(Statement command, DateTime value) throws Exception
	{
		value.setTimezoneOffset(0);// cut off tz
		value.setYear(1970); value.setMonth(1); value.setDay(1);
		java.util.Calendar cal = java.util.Calendar.getInstance();
		long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
		long ms = value.getValue().getTimeInMillis();
		java.sql.Time time = new java.sql.Time(ms);
		time.setTime( time.getTime() - tzoffset );
		command.bindParameter(time);
	}
	
	public static void bindParameter_TimeTZ(Statement command, DateTime value) throws Exception
	{
		value.setYear(1970); value.setMonth(1); value.setDay(1);
		long ms = value.getValue().getTimeInMillis();
		java.sql.Time time = new java.sql.Time(ms);
		command.bindParameter(time);
	}
	
	public static void bindParameter_long(Statement command, long value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_int(Statement command, int value) throws Exception
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_boolean(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_binary(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_BigInteger(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_double(Statement command, Object value)
	{
		command.bindParameter(value);
	}
	
	public static void bindParameter_IntervalDaySecond(Statement command, Duration duration) throws Exception
	{
		StringBuilder s = new StringBuilder();
		if (duration.isNegative())
			s.append("-");
		else
			s.append("+");
		
		s.append(java.lang.Math.abs(duration.getDay()));
		s.append(" ");
		s.append(java.lang.Math.abs(duration.getHour()));
		s.append(":");
		s.append(java.lang.Math.abs(duration.getMinute()));
		s.append(":");
		
		double seconds = java.lang.Math.abs(duration.getSecond())
					   + java.lang.Math.abs(duration.getPartSecond());
		DecimalFormatSymbols symbols = new DecimalFormatSymbols(java.util.Locale.US);
		DecimalFormat formatter = new DecimalFormat("00.0###############", symbols);
		s.append(formatter.format(seconds));
		
		command.bindParameter(s.toString());
	}
	
	public static void bindParameter_IntervalYearMonth(Statement command, Duration duration) throws Exception
	{
		StringBuilder s = new StringBuilder();
		if (duration.isNegative())
			s.append("-");
		else
			s.append("+");

		s.append(java.lang.Math.abs(duration.getYear()));
		s.append("-");
		s.append(java.lang.Math.abs(duration.getMonth()));
				
		command.bindParameter(s.toString());
	}
	
	
	// vendor specific functions
	
	public static class Oracle
	{
		public static void bindParameter_BigDecimal(Statement command, BigDecimal value) throws Exception
		{
			if( (checkForJdbcOdbcConnection(command.getConnection())) )
			{
				value = value.stripTrailingZeros();
				String s = value.toPlainString();
				value = new BigDecimal(s);
			}
			command.bindParameter(value, value.scale());
		}

		public static void bindParameter_IntervalYearMonth(Statement command, Duration duration) throws Exception
		{
			Dbs.bindParameter_IntervalYearMonth(command, duration);
		}

		public static void bindParameter_IntervalDaySecond(Statement command, Duration duration) throws Exception
		{
			Dbs.bindParameter_IntervalDaySecond(command, duration);
		}

		public static void bindParameter_char(Statement command, String value)
		{
			Statement.Parameter parameter = command.getParameter(command.getValues().size());
			if( parameter != null && parameter.type == java.sql.Types.CHAR && parameter.scaleOrLength > value.length() )
			{
				value = String.format("%1$-" + parameter.scaleOrLength + "s", value);  
			}
			command.bindParameter(value);
		}


		public static void read_IntervalYearToMonth_Object(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
					
			//if( obj instanceof oracle.sql.INTERVALYM ) {
			//	oracle.sql.INTERVALYM ym = (oracle.sql.INTERVALYM)(obj);
			//	byte[] paramArrayOfByte = ym.toBytes();
			if( (obj != null) && (obj.getClass().getName().equals("oracle.sql.INTERVALYM")) ) {
				java.lang.reflect.Method method = obj.getClass().getMethod("toBytes", (Class<?>[])(null));
				byte[] paramArrayOfByte = (byte[])(method.invoke(obj, (Object[])(null))); 					
				
				int INTYMYEAROFFSET = -2147483648;
				int INTYMMONTHOFFSET = 60;
				
				int j  = (paramArrayOfByte[0] & 0xFF) << 24;
					j |= (paramArrayOfByte[1] & 0xFF) << 16;
					j |= (paramArrayOfByte[2] & 0xFF) << 8;
					j |= (paramArrayOfByte[3] & 0xFF);
					j -= INTYMYEAROFFSET;

				int k = paramArrayOfByte[4] - INTYMMONTHOFFSET;	
			
				boolean positive = true;
				if( j < 0 || k < 0 ) { 
					positive = false;
					j = Math.abs(j);
					k = Math.abs(k);
				}
				
				Duration duration = new Duration(j, k, 0, 0, 0, 0, 0.0, !positive );
				record.fields.put(name, new MFSingletonSequence(duration));
			}
			else
			{
				read_IntervalYearToMonth_String(record, recordset, name, column);
			}
		}

		public static void read_IntervalYearToMonth_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			com.altova.db.Dbs.read_String_ParseIntervalYearToMonth(record, recordset, name, column);
		}

		public static void read_IntervalDayToSecond_Object(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
					
			//if( obj instanceof oracle.sql.INTERVALDS ) {
			//	oracle.sql.INTERVALDS ds = (oracle.sql.INTERVALDS)(obj);
			//	byte[] paramArrayOfByte = ds.toBytes();
			if( (obj != null) && (obj.getClass().getName().equals("oracle.sql.INTERVALDS")) ) {
				java.lang.reflect.Method method = obj.getClass().getMethod("toBytes", (Class<?>[])(null));
				byte[] paramArrayOfByte = (byte[])(method.invoke(obj, (Object[])(null)));

				int INTERVALDSOFFSET = 60;
				int INTERVALDAYOFFSET = -2147483648;

				int d  = (paramArrayOfByte[0] & 0xFF) << 24;
					d |= (paramArrayOfByte[1] & 0xFF) << 16;
					d |= (paramArrayOfByte[2] & 0xFF) << 8;
					d |= (paramArrayOfByte[3] & 0xFF);
					d -= INTERVALDAYOFFSET;

				int h = paramArrayOfByte[4] - INTERVALDSOFFSET;
				int m = paramArrayOfByte[5] - INTERVALDSOFFSET;
				int s = paramArrayOfByte[6] - INTERVALDSOFFSET;

				int n  = (paramArrayOfByte[7] & 0xFF) << 24;
					n |= (paramArrayOfByte[8] & 0xFF) << 16;
					n |= (paramArrayOfByte[9] & 0xFF) << 8;
					n |= (paramArrayOfByte[10] & 0xFF);
					n -= INTERVALDAYOFFSET;

				boolean positive = true;
				if (d < 0 || h < 0 || m < 0 || s < 0 || n < 0) {
					positive = false;
					d = Math.abs(d);
					h = Math.abs(h);
					m = Math.abs(m);
					s = Math.abs(s);
					n = Math.abs(n);
				}

				double nano = 1000.0*1000.0*1000.0;
				double frac = n/nano;// nano to sec
				
				Duration duration = new Duration(0, 0, d, h, m, s, frac, !positive );
				record.fields.put(name, new MFSingletonSequence(duration));
			}
			else
			{
				read_IntervalDayToSecond_String(record, recordset, name, column);
			}
		}

		public static void read_IntervalDayToSecond_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			com.altova.db.Dbs.read_String_ParseIntervalDayToSecond(record, recordset, name, column);
		}

		public static void read_double(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Number value = (Number) recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			double d = 0.0;
			if( value instanceof Float )
			{// avoid rounding issues (binary float)
				String s = ((Float)(value)).toString();
				d = Double.valueOf(s).doubleValue();
			}
			else { d = value.doubleValue(); }
			record.fields.put(name, new MFSingletonSequence(d));
		}

		public static void read_Decimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Number number = (Number) recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}	
			
			BigDecimal value = null;
			if( number instanceof BigDecimal )
				value = (BigDecimal)(number);
			else
				value = BigDecimal.valueOf(number.doubleValue());
			
			record.fields.put(name, new MFSingletonSequence(value));
		}
	}

	public static class DB2
	{
		public static void bindParameter_Graphic(Statement command, String value) throws Exception
		{
			command.bindParameter(value,0);
		}


		public static void read_Graphic(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DbClob(record,recordset,name, column);
		}

		public static void read_Clob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( !(checkForJdbcOdbcResultSet(resultSet)) )
			{// any other result set kind - simply read the string content
				com.altova.db.Dbs.read_String(record, recordset, name, column);
				return; // done
			}

			byte[] bytes = resultSet.getBytes(column+1);
			if (resultSet.wasNull() || bytes == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			String content = new String(bytes,"UTF-8") ;
			record.fields.put(name, new MFSingletonSequence(content));
		}

		public static void read_DbClob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( !(checkForJdbcOdbcResultSet(resultSet)) )
			{// any other result set kind - simply read the string content
				com.altova.db.Dbs.read_String(record, recordset, name, column);
				return; // done
			}

			byte[] bytes = resultSet.getBytes(column+1);
			if (resultSet.wasNull() || bytes == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			String content = new String(bytes,"UTF-16BE") ;
			record.fields.put(name, new MFSingletonSequence(content));
		}
	}
	
	public static class Informix
	{
		public static void bindParameter_DateTime(Statement command, DateTime value) throws Exception
		{
			value.setTimezoneOffset(0);// cut off tz
			int year = value.getYear();
			int month = value.getMonth();
			int day = value.getDay();
			int hour = value.getHour();
			int minute = value.getMinute();
			int second = value.getSecond();
			java.util.Calendar cal = java.util.Calendar.getInstance();
			long tzoffset = cal.get(java.util.Calendar.ZONE_OFFSET);
			cal.set(java.util.Calendar.ZONE_OFFSET, 0);
			cal.set(java.util.Calendar.DST_OFFSET, 0);
			cal.set( year, month-1, day, hour, minute, second);
			long millisec = cal.getTimeInMillis() - tzoffset;
			java.sql.Timestamp ts = new java.sql.Timestamp(millisec);
			ts.setNanos((int)(value.getPartSecond() * 1000000000));
			command.bindParameter(ts);
		}

		public static void bindParameter_IntervalYearYear(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Year);
		}
		public static void bindParameter_IntervalYearMonth(Statement command, Duration duration) throws Exception
		{
			Dbs.bindParameter_IntervalYearMonth(command, duration);// base implementation
		}
		public static void bindParameter_IntervalMonthMonth(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, new Duration(0,java.lang.Math.abs(duration.getYearMonthValue()),0,0,0,0,0.0,duration.isNegative()), DurationPart_Month);
		}
		public static void bindParameter_IntervalDayDay(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Day);
		}
		public static void bindParameter_IntervalDayHour(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour);
		}
		public static void bindParameter_IntervalDayMinute(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
		}
		public static void bindParameter_IntervalDaySecond(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
		}
		public static void bindParameter_IntervalDayFraction(Statement command, Duration duration) throws Exception
		{
			Dbs.bindParameter_IntervalDaySecond(command, duration);// base implemetation
		}
		public static void bindParameter_IntervalHourHour(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Hour);
		}
		public static void bindParameter_IntervalHourMinute(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute);
		}
		public static void bindParameter_IntervalHourSecond(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
		}
		public static void bindParameter_IntervalHourFraction(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalMinuteMinute(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Minute);
		}
		public static void bindParameter_IntervalMinuteSecond(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Minute|DurationPart_Second);
		}
		public static void bindParameter_IntervalMinuteFraction(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalSecondSecond(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Second);
		}
		public static void bindParameter_IntervalSecondFraction(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalFractionFraction(Statement command, Duration duration) throws Exception
		{
			bindParameter_Interval_Informix(command, duration, DurationPart_Fraction);
		}

		public static void bindParameter_Interval_Informix(Statement command, Duration duration, int parts) throws Exception
		{
			StringBuilder s = new StringBuilder();
			if (duration.isNegative())
				s.append("-");

			if( (parts & DurationPart_Year) == DurationPart_Year )
				s.append(java.lang.Math.abs(duration.getYear()));
			if(((parts & DurationPart_Year) == DurationPart_Year) && ((parts & DurationPart_Month) == DurationPart_Month) )
				s.append("-");
			if( (parts & DurationPart_Month) == DurationPart_Month )
				s.append(java.lang.Math.abs(duration.getMonth()));
			if(((parts & DurationPart_Month) == DurationPart_Month) && ((parts & DurationPart_Day) == DurationPart_Day) )
				s.append("-");
			if( (parts & DurationPart_Day) == DurationPart_Day )
				s.append(java.lang.Math.abs(duration.getDay()));
			if(((parts & DurationPart_Day) == DurationPart_Day) && ((parts & DurationPart_Hour) == DurationPart_Hour) )
				s.append(" ");
			if( (parts & DurationPart_Hour) == DurationPart_Hour )
				s.append(java.lang.Math.abs(duration.getHour()));
			if(((parts & DurationPart_Hour) == DurationPart_Hour) && ((parts & DurationPart_Minute) == DurationPart_Minute) )
				s.append(":");
			if( (parts & DurationPart_Minute) == DurationPart_Minute )
				s.append(java.lang.Math.abs(duration.getMinute()));
			if(((parts & DurationPart_Minute) == DurationPart_Minute) && ((parts & DurationPart_Second) == DurationPart_Second) )
				s.append(":");
			
			if( (parts & (DurationPart_Second)) == (DurationPart_Second) ) {
				s.append(java.lang.Math.abs(duration.getSecond()));				
			} 
			if( (parts & (DurationPart_Fraction)) == (DurationPart_Fraction) ) {
				double seconds = java.lang.Math.abs(duration.getPartSecond());
				DecimalFormatSymbols symbols = new DecimalFormatSymbols(java.util.Locale.US);
				DecimalFormat formatter = new DecimalFormat("0.0###############", symbols);
				s.append(formatter.format(seconds).substring(1));
			}
			
			command.bindParameter(s.toString());
		}

		public static void bindParameter_blob(Statement command, Object value)
		{
			command.bindParameter(new java.io.ByteArrayInputStream((byte[])value));
		}

		public static void bindParameter_clob(Statement command, String value)
		{
			command.bindParameter(new java.io.StringReader(value));
		}

		public static void bindParameter_char(Statement command, String value) throws Exception
		{
			int parameterType = ( checkForJdbcOdbcConnection(command.getConnection()) ) ? java.sql.Types.VARCHAR : java.sql.Types.CHAR;
			command.setParameterType(command.getValues().size(), parameterType );// jdbcodbc bridge triggers an error when parameter is char

			bindParameter_String(command, value);
		}

		public static void bindParameter_varchar(Statement command, String value) throws Exception
		{
			int parameterType = ( checkForJdbcOdbcConnection(command.getConnection()) ) ? java.sql.Types.VARCHAR : java.sql.Types.LONGVARCHAR;
			command.setParameterType(command.getValues().size(), parameterType );// jdbcodbc bridge triggers an error when parameter is longvarchar

			bindParameter_String(command, value);
		}


		public static void read_bigint(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object value = recordset.getResultSet().getLong(column+1);
			
			if (recordset.getResultSet().wasNull() || value == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			if((checkForJdbcOdbcResultSet(recordset.getResultSet())) // fix rounding error
			&& (value instanceof java.lang.Long) && (((Long)(value)).longValue()== java.lang.Long.MIN_VALUE) )
				value = new java.lang.Long(java.lang.Long.MIN_VALUE+1);// -9223372036854775807
			
			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_clob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( !(checkForJdbcOdbcResultSet(resultSet)) )
			{// any other result set kind - simply read the string content
				com.altova.db.Dbs.read_String(record, recordset, name, column);
				return; // done
			}

			byte[] bytes = resultSet.getBytes(column+1);
			if (resultSet.wasNull() || bytes == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			String content = new String(bytes,"UTF-8") ;
			record.fields.put(name, new MFSingletonSequence(content));
		}

		public static final int DurationPart_Year = 1 << 0;
		public static final int DurationPart_Month = 1 << 1;
		public static final int DurationPart_Day = 1 << 2;
		public static final int DurationPart_Hour = 1 << 3;
		public static final int DurationPart_Minute = 1 << 4;
		public static final int DurationPart_Second = 1 << 5;
		public static final int DurationPart_Fraction = 1 << 6;
		
		public static void read_DateTimeYearToYear(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Year);
		}
		public static void read_DateTimeMonthToMonth(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month);
		}
		public static void read_DateTimeMonthToDay(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day);
		}
		public static void read_DateTimeMonthToHour(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour);
		}
		public static void read_DateTimeMonthToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
		}
		public static void read_DateTimeMonthToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
		}
		public static void read_DateTimeMonthToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Month|DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_DateTimeDayToDay(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Day);
		}
		public static void read_DateTimeDayToHour(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour);
		}
		public static void read_DateTimeDayToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
		}
		public static void read_DateTimeDayToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
		}
		public static void read_DateTimeDayToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_DateTimeHourToHour(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour);
		}
		public static void read_DateTimeHourToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute);
		}
		public static void read_DateTimeHourToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute|DurationPart_Second);
		}
		public static void read_DateTimeHourToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_DateTimeMinuteToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute);
		}
		public static void read_DateTimeMinuteToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute|DurationPart_Second);
		}
		public static void read_DateTimeMinuteToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_DateTimeSecondToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Second);
		}
		public static void read_DateTimeSecondToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_DateTimeFractionToFraction(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_DateTime_Informix(record, recordset, name, column, DurationPart_Fraction);
		}

		public static void read_DateTime_Informix(Record record, ResultSetWrapper recordset, String name, int column, int parts) throws Exception
		{
			String str = recordset.getResultSet().getString(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			Duration.RefInt n = new Duration.RefInt(0);
			str = str.trim();// strip leading/trailing white spaces
			CalendarBase.ParseContext context = new Duration.ParseContext(str);
			String err = str + " cannot be converted to a datetime value.";
			if (!context.isValid()) throw new StringParseException(err,2);

			int year = 1200;
			int month = 1;
			int day = 1; 
			int hour = 0;
			int minute = 0;
			int second = 0;
			double fraction = 0.0;
			
			if( (parts & DurationPart_Year) == DurationPart_Year ) {
				year = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { year = (year * 10) + n.value; n.value = 0; }
			}
			if(((parts & (DurationPart_Year|DurationPart_Month)) == (DurationPart_Year|DurationPart_Month)) ) {
				if(!context.checkAndAdvance('-')) throw new StringParseException(err,2);
			}
			if( (parts & DurationPart_Month) == DurationPart_Month ) {
				month = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
			}
			if(((parts & (DurationPart_Month|DurationPart_Day)) == (DurationPart_Month|DurationPart_Day)) ) {
				if(!context.checkAndAdvance('-')) throw new StringParseException(err,2);
			}
			if( (parts & DurationPart_Day) == DurationPart_Day ) {
				day = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { day = (day * 10) + n.value; n.value = 0; }
			}
			if(((parts & (DurationPart_Day|DurationPart_Hour)) == (DurationPart_Day|DurationPart_Hour)) ) {
				if(!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
			}
			if( (parts & DurationPart_Hour) == DurationPart_Hour ) {
				hour = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { hour = (hour * 10) + n.value; n.value = 0; }
			}
			if(((parts & (DurationPart_Hour|DurationPart_Minute)) == (DurationPart_Hour|DurationPart_Minute)) ) {
				if(!context.checkAndAdvance(':')) throw new StringParseException(err,2);
			}
			if( (parts & DurationPart_Minute) == DurationPart_Minute ) {
				minute = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { minute = (minute * 10) + n.value; n.value = 0; }
			}
			if(((parts & (DurationPart_Minute|DurationPart_Second)) == (DurationPart_Minute|DurationPart_Second)) ) {
				if(!context.checkAndAdvance(':')) throw new StringParseException(err,2);
			}
			if( (parts & DurationPart_Second) == DurationPart_Second ) {
				second = 0;
				if (!context.isValid()) throw new StringParseException(err,2);
				while(context.readDigitAndAdvance(n, 1, 9)) { second = (second * 10) + n.value; n.value = 0; }
			}
			if( (parts & DurationPart_Fraction) == DurationPart_Fraction ) {
				if( context.checkAndAdvance('.') )
				{
					int temp = 0; 
					int start = context.index();
					if(!context.isValid()) throw new StringParseException(str,2);
					while (context.readDigitAndAdvance(n, 1, 9)) { temp = (temp * 10) + n.value; n.value = 0; }
					int end = context.index();
					fraction = temp / Math.pow( 10, end-start );
				}
			}

			com.altova.types.DateTime val = new com.altova.types.DateTime(year,month,day,hour,minute,second,fraction);
			record.fields.put(name, new MFSingletonSequence(val));
		}

		public static void read_IntervalYearToMonth_Object(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
					
			if( (obj != null) && (obj.getClass().getName().equals("com.informix.lang.IntervalYM")) ) {
				java.lang.reflect.Method method = obj.getClass().getMethod("getMonths", (Class<?>[])(null));
				Long months = (Long)(method.invoke(obj, (Object[])(null))); 					
				
				int y = (int)(months/12);
				int m = (int)(months%12);
			
				boolean positive = true;
				if( y < 0 || m < 0 ) { 
					positive = false;
					y = Math.abs(y);
					m = Math.abs(m);
				}
				
				Duration duration = new Duration(y, m, 0, 0, 0, 0, 0.0, !positive );
				record.fields.put(name, new MFSingletonSequence(duration));
			}
			else
			{
				read_IntervalYearToMonth_String(record, recordset, name, column);
			}
		}

		public static void read_IntervalYearToMonth_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_String_ParseIntervalYearToMonth(record, recordset, name, column);
		}

		public static void read_IntervalDayToSecond_Object(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			if( (obj != null) && (obj.getClass().getName().equals("com.informix.lang.IntervalDF")) ) {
				java.lang.reflect.Method methodGetSeconds = obj.getClass().getMethod("getSeconds", (Class<?>[])(null));
				Long seconds = (Long)(methodGetSeconds.invoke(obj, (Object[])(null)));
				java.lang.reflect.Method methodGetNanoSeconds = obj.getClass().getMethod("getNanoSeconds", (Class<?>[])(null));
				Long nanos = (Long)(methodGetNanoSeconds.invoke(obj, (Object[])(null)));
				
				int d = (int)((seconds / (60*60*24)));
				int h = (int)((seconds / (60*60)) % 24);
				int m = (int)((seconds / 60) % 60);
				int s = (int)(seconds % 60);
				int n = nanos.intValue();
				
				boolean positive = true;
				if (d < 0 || h < 0 || m < 0 || s < 0 || n < 0) {
					positive = false;
					d = Math.abs(d);
					h = Math.abs(h);
					m = Math.abs(m);
					s = Math.abs(s);
					n = Math.abs(n);
				}
				
				double nano = 1000.0*1000.0*1000.0;
				double frac = n/nano;// nano to sec
				//double sec = s + frac;
				
				Duration duration = new Duration(0, 0, d, h, m, s, frac, !positive );
				record.fields.put(name, new MFSingletonSequence(duration));
			}
			else
			{
				read_IntervalDayToSecond_String(record, recordset, name, column);
			}	
		}

		public static void read_IntervalDayToSecond_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_String_ParseIntervalDayToSecond(record, recordset, name, column);
		}

		public static void read_decimal(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			BigDecimal value = resultSet.getBigDecimal(column+1);
			if (resultSet.wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			record.fields.put(name, new MFSingletonSequence(value));
		}
	}

	public static class iSeries
	{
	}

	public static class SQLServer
	{
		public static void bindParameter_nchar(Statement command, String value) throws Exception
		{
			if( checkForJdbcOdbcConnection(command.getConnection()) ) 
			{// fix for SQLServer nchar, nvarchar
				int i = command.getValues().size();
				command.setParameterType(i, java.sql.Types.BINARY);
				command.bindParameter(java.nio.charset.Charset.forName("UTF-16LE").encode(value).array());
			}
			else
			{
				bindParameter_String( command, value );			
			}
		}

		public static void bindParameter_DateTimeOffset(Statement command, DateTime value) throws Exception
		{
			command.bindParameter(value.toString());
		}

		public static void bindParameter_BigDecimal(Statement command, BigDecimal value) throws Exception
		{
			com.altova.db.Statement.Parameter p = command.getParameter(command.getValues().size()); 
			if( p.scaleOrLength > 0 ){ value = value.setScale(p.scaleOrLength, java.math.RoundingMode.HALF_DOWN); }
			if( value.scale() >= 60 ) 
			{// driver has problems with large scale decimals 
				value = value.stripTrailingZeros();
			}
			command.bindParameter(value, value.scale());
		}


		public static void read_DateTimeOffset(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
/*			DateTime value = null;
			if(obj instanceof microsoft.sql.DateTimeOffset)
			{			
				microsoft.sql.DateTimeOffset dt = (microsoft.sql.DateTimeOffset)obj;
				java.sql.Timestamp ts = dt.getTimestamp(); 
				java.util.TimeZone tz = java.util.TimeZone.getDefault();
				int dst = tz.useDaylightTime() && tz.inDaylightTime(ts) ? tz.getDSTSavings() : 0;
				tz.setRawOffset( (dt.getMinutesOffset() * 60000) - dst );
				java.util.Calendar cal = java.util.Calendar.getInstance(tz);
				cal.set(java.util.Calendar.ZONE_OFFSET, 0);
				cal.setTimeInMillis(ts.getTime());
				
				value = new com.altova.types.DateTime(cal);
				value.setHasTimezone(DateTime.TZ_OFFSET);
				value.setTimezoneOffset(dt.getMinutesOffset());
			} 
	*/
			DateTime value = new DateTime();
			java.lang.String s = obj.toString(); 
			java.lang.String[] part = s.split(" ");
			s = part[0] + "T" + part[1] + part[2];
			value.parseDateTime(s, DateTime.DateTimePart_Date | DateTime.DateTimePart_Time);

			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_ntext(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( !(checkForJdbcOdbcResultSet(resultSet)) )
			{// any other result set kind - simply read the string content
				com.altova.db.Dbs.read_String(record, recordset, name, column);
				return; // done
			}

			byte[] bytes = resultSet.getBytes(column+1);
			if (resultSet.wasNull() || bytes == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			String content = new String(bytes,"UTF-16LE") ;
			record.fields.put(name, new MFSingletonSequence(content));
		}

	}

	public static class PostgreSQL
	{
		public static void bindParameter_money(Statement command, Double value) throws Exception
		{
			command.bindParameter(value != null ? value.toString() : null); // transfer as string 
		}

		public static void bindParameter_Interval(Statement command, Duration duration) throws Exception
		{
			StringBuilder s = new StringBuilder();

			s.append(duration.getYear());
			s.append(" year ");
			s.append(duration.getMonth());
			s.append(" month ");
			s.append(duration.getDay());
			s.append(" day ");

			if((duration.getHour() < 0)
			|| (duration.getMinute() < 0)
			|| (duration.getSecond() < 0)
			|| (duration.getPartSecond() < 0.0))
			{
				s.append("-");
				duration.setNegative(false);
			}
				
			s.append(duration.getHour());
			s.append(":");
			s.append(duration.getMinute());
			s.append(":");
			s.append(duration.getSecond() + duration.getPartSecond());
			
			command.bindParameter(s.toString());	
		}

		public static void bindParameter_DateTimeTZ(Statement command, DateTime value) throws Exception
		{
			StringBuffer s = new StringBuffer();
			s.append( value.toDateString() );
			s.append(" ");
			s.append( value.toTimeString() );
			command.bindParameter(s.toString());
		}


		public static void read_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			String str = recordset.getResultSet().getString(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			str = str.replaceAll("\\r\\n", "\n");
			record.fields.put(name, new MFSingletonSequence(str));
		}

		public static void read_TimeTZ_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			String str = recordset.getResultSet().getString(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
					
			int optional = CalendarBase.DateTimePart_TimezoneMinute;

			DateTime value = new DateTime();
			value.parseTime(str.trim(), optional);
			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_TimestampTZ(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			if( checkForJdbcOdbcResultSet(recordset.getResultSet()) ) {
				read_DateTime(record, recordset, name, column);
				return;
			}
			
			String str = recordset.getResultSet().getString(column+1);
			if (recordset.getResultSet().wasNull() || str == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}

			// "YYYY-MM-DD hh:mm:ss.fff+TH"
			String datePart = str.substring(0, str.indexOf(" "));
			str = str.substring(datePart.length()).trim();
			int timeEnd = str.indexOf("+") != -1 ? str.indexOf("+")
						: str.indexOf("-") != -1 ? str.indexOf("-")
						: str.length();
			String timePart = str.substring(0, timeEnd);
			String zonePart = str.substring(timeEnd).trim();
			if(zonePart.indexOf(":") == -1) zonePart += ":00";
			
			DateTime dt = new com.altova.types.DateTime();
			dt.parseDate(datePart);
			dt.parseTime(timePart + zonePart);
			record.fields.put(name, new MFSingletonSequence(dt));
		}

		public static void read_Interval_Object(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			//if( obj instanceof org.postgresql.util.PGInterval ) {
			//	org.postgresql.util.PGInterval interval = (org.postgresql.util.PGInterval)(obj);
			//	int year = interval.getYears();
			//	int month = interval.getMonths();
			//	int day = interval.getDays();
			//	int hour = interval.getHours();
			//	int minute = interval.getMinutes();
			//	double s = interval.getSeconds();
			if( (obj != null) && (obj.getClass().getName().equals("org.postgresql.util.PGInterval")) ) {
				Object[] a = null;
				Class<?>[] v = null;
				Class<?> c = obj.getClass();
				int year = ((Integer)(c.getMethod("getYears", v).invoke(obj, a))).intValue(); 					
				int month = ((Integer)(c.getMethod("getMonths", v).invoke(obj, a))).intValue(); 					
				int day = ((Integer)(c.getMethod("getDays", v).invoke(obj, a))).intValue(); 					
				int hour = ((Integer)(c.getMethod("getHours", v).invoke(obj, a))).intValue(); 					
				int minute = ((Integer)(c.getMethod("getMinutes", v).invoke(obj, a))).intValue(); 					
				double s = ((Double)(c.getMethod("getSeconds", v).invoke(obj, a))).doubleValue(); 					
				int second = (int)(s);
				double fraction = s - second;
				boolean positive = (year>=0) && (month>=0) && (day>=0) && (hour>=0) && (minute>=0) && (second>=0) && (fraction>=0.0);
				if(!positive) {
					year = -Math.abs(year);
					month = -Math.abs(month);
					day = -Math.abs(day);
					hour = -Math.abs(hour);
					minute = -Math.abs(minute);
					second = -Math.abs(second);
					fraction = -Math.abs(fraction);
				}
				Duration duration = new Duration(year, month, day, hour, minute, second, fraction, !positive );
				record.fields.put(name, new MFSingletonSequence(duration));
			}
			else
			{
				read_Interval_String(record, recordset, name, column);
			}
		}

		public static void read_Interval_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			String str = recordset.getResultSet().getString(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			// Format: YYYY/MM/DD/hh/mm/ss.ff9

			boolean positive = true;
			double fraction = 0.0;

			Duration.RefInt n = new Duration.RefInt(0); 
			CalendarBase.ParseContext context = new Duration.ParseContext(str.trim());
			String err = str + " cannot be converted to a duration value.";

			int years = 0; // parse year component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }
			if (!context.isValid()) throw new StringParseException(err,2);

			if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);
			
			int month = 0; // parse month component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { month = (month * 10) + n.value; n.value = 0; }
			if (!context.isValid()) throw new StringParseException(err,2);
			
			if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

			int days = 0; // parse days component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(err,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
			if (!context.isValid()) throw new StringParseException(err,2);
			
			if(!context.checkAndAdvance('/')) throw new StringParseException(err,2);

			int hours = 0; // parse hour component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(str,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { hours = (hours * 10) + n.value; n.value = 0; }
			if (!context.isValid()) throw new StringParseException(str,2);

			if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

			int minutes = 0; // parse minute component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(str,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { minutes = (minutes * 10) + n.value; n.value = 0; }
			if (!context.isValid()) throw new StringParseException(str,2);

			if(!context.checkAndAdvance('/')) throw new StringParseException(str,2);

			int seconds = 0; // parse seconds component
			if( context.checkAndAdvance('-') ) positive = false;
			if (!context.isValid()) throw new StringParseException(str,2);
			while(context.readDigitAndAdvance(n, 1, 9)) { seconds = (seconds * 10) + n.value; n.value = 0; }
			if(!context.isValid()) throw new StringParseException(str,2);
			if( context.checkAndAdvance('.') )
			{
				int temp = 0; // microseconds
				if(!context.isValid()) throw new StringParseException(str,2);
				while (context.readDigitAndAdvance(n, 1, 9)) { temp = (temp * 10) + n.value; n.value = 0; }
				fraction = temp / 1000000.0;
			}
			
			Duration duration = new Duration(years, month, days, hours, minutes, seconds, fraction, !positive );
			record.fields.put(name, new MFSingletonSequence(duration));
		}

		public static void read_Boolean_int(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Number value = (Number) recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			record.fields.put(name, new MFSingletonSequence(value.intValue()!=0));
		}

		public static void read_money(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			ResultSet resultSet = recordset.getResultSet(); 
			if( checkForJdbcOdbcResultSet(resultSet) )
			{// the jdbc odbc bridge correctly converts money types
				read_double( record, recordset, name, column);
				return;
			}

			// when using the PostgreSQL JDBC Interface
			String str = resultSet.getString(column+1);
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}

			java.util.Locale locale = java.util.Locale.US; //java.util.Locale.getDefault();
			java.text.NumberFormat format = java.text.NumberFormat.getCurrencyInstance(locale);
			double value = format.parse( str ).doubleValue();
			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_uuid(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( checkForJdbcOdbcResultSet(resultSet) )
			{// when using the JdbcOdbc bridge, read as binary and convert to guid  
				com.altova.db.Dbs.read_binary_Guid(record, recordset, name, column);
			}
			else
			{// native driver such as "PostgreSQL X.Y JDBC4" must read as string 
				com.altova.db.Dbs.read_string_Guid(record, recordset, name, column);
			}
		}

		public static void read_xml(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			String content = internal_read_unicodestring( resultSet, column, "UTF-8" );
			if (resultSet.wasNull() || content == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			content = content.replace("\r\n", "\n");
			record.fields.put(name, new MFSingletonSequence(content));
		}
	}

	public static class MySQL
	{
		public static void bindParameter_BigInteger(Statement command, Object value) throws Exception
		{
			if( (checkForJdbcOdbcConnection(command.getConnection()))
			&&  (command.getConnection().getMetaData().getDriverName().contains("myodbc3")) )
			{// fix for MySQL Driver 3.51 with unsigned bigint types
				command.bindParameter(value.toString());
			}
			else
			{// ODBC Driver 5.1 and Connector/J
				command.bindParameter(value);
			}
		}


		private static long internal_read_year( java.sql.ResultSet resultSet, int column, java.util.Date value ) throws Exception
		{
			java.util.Calendar cal = java.util.Calendar.getInstance();
			cal.setTime(value); // assign given date
			long year = cal.get(java.util.Calendar.YEAR);

			java.sql.ResultSetMetaData meta = resultSet.getMetaData();
			if( meta != null && meta.getPrecision(column+1) == 2 )
				year -= (year >= 2000 ? 2000 : 1900);
			
			return year;
		}

		public static void read_year(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet(); 
			Object value = resultSet.getObject(column+1);
			
			if (resultSet.wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			if( value instanceof Number )
			{
				long year = ((Number)value).longValue();
				record.fields.put(name, new MFSingletonSequence(year));
				return;
			}

			if( value instanceof java.util.Date )
			{
				long year = internal_read_year( resultSet, column, (java.util.Date)value);
				record.fields.put(name, new MFSingletonSequence(year));
				return;
			}
			// error ?
		}

		public static void read_String(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			if( checkForJdbcOdbcResultSet(recordset.getResultSet()) && queryForOdbcMajorDriverVersion(recordset.getResultSet()) > 3 ) 
			{
				byte[] blob = recordset.getResultSet().getBytes(column+1);
				if (blob == null || recordset.getResultSet().wasNull())
				{
					record.fields.put(name, new MFEmptySequence());
					return;
				}
			
				String str = new String(blob, java.nio.charset.Charset.forName("UTF-8"));
				record.fields.put(name, new MFSingletonSequence(str));
			} 
			else 
			{
				com.altova.db.Dbs.read_String(record, recordset, name, column);
			}
		}

		public static void read_longtext(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			String str = null;
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( checkForJdbcOdbcResultSet(resultSet) && (resultSet.getMetaData().getPrecision(column+1) < 0) ) {
				java.io.Reader r = resultSet.getCharacterStream(column+1);
				if( r != null && !resultSet.wasNull() ) {
					int c=0;
					java.lang.StringBuilder sb = new StringBuilder(); 
					while( (c=r.read()) != -1 ) sb.appendCodePoint(c);
					str = sb.length() > 0 ? sb.toString() : null;
				}
			} else { 
				str = resultSet.getString(column+1);
			}
			
			if (resultSet.wasNull() || str == null )
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			record.fields.put(name, new MFSingletonSequence(str));
		}

		public static void read_Bitfield(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			byte[] blob = recordset.getResultSet().getBytes(column+1);
			
			if (recordset.getResultSet().wasNull() || blob == null)
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			BigInteger value = new BigInteger( 1, blob ); 
			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_ubigint(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			BigInteger value = new BigInteger(obj.toString()); 
			record.fields.put(name, new MFSingletonSequence(value));
		}

		public static void read_binary(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.io.InputStream is = recordset.getResultSet().getBinaryStream(column+1);
			java.io.ByteArrayOutputStream os = new java.io.ByteArrayOutputStream();
			
			if( is != null )
			{
				int v;
				while( (v = is.read()) != -1 )
					os.write(v);
			}
			
			byte[] blob = os.toByteArray(); 
			
			if( (recordset.getResultSet().wasNull()) || (blob.length == 0) ) 
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			record.fields.put(name, new MFSingletonSequence(blob));
		}
	}

	public static class Sybase
	{
		public static void bindParameter_nchar(Statement command, String value) throws Exception
		{
			if( command.getConnection().getMetaData().getDatabaseMajorVersion() > 12 ) 
			{
				bindParameter_String( command, value );
			} 
			else 
			{
				if(value.length() > 0) {
					int i = command.getValues().size();
					command.setParameterType(i, java.sql.Types.BINARY);
					command.bindParameter(java.nio.charset.Charset.forName("ISO-8859-1").encode(value).array());
				}
				else
				{
					int i = command.getValues().size();
					command.setParameterType(i, java.sql.Types.VARCHAR);
					command.bindParameter( value );
				}
			}
		}


		public static void read_ntext(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.ResultSet resultSet = recordset.getResultSet();
			if( checkForJdbcOdbcResultSet(resultSet) )
			{// when using the jdbc odbc bridge ...
				com.altova.db.Dbs.read_String(record, recordset, name, column);
				return; // done
			}
			if( resultSet.getStatement().getConnection().getMetaData().getDatabaseMajorVersion() > 12 ) 
			{
				com.altova.db.Dbs.read_String(record, recordset, name, column);
			}
			else
			{
				java.io.InputStream reader = resultSet.getAsciiStream(column+1);
				String content = internal_read_unicodestring( resultSet, reader );
				if (resultSet.wasNull() || content == null)
				{
					record.fields.put(name, new MFEmptySequence());
					return;
				}
				
				record.fields.put(name, new MFSingletonSequence(content));
			}
		}	

		public static void read_DateTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			java.sql.Timestamp ts = (java.sql.Timestamp)obj;
			java.util.Calendar cal = java.util.Calendar.getInstance();
			cal.setTimeInMillis(ts.getTime());
			DateTime value = new com.altova.types.DateTime(cal);
			record.fields.put(name, new MFSingletonSequence(value));
		}
	}

	public static class Firebird
	{
		public static void bindParameter_Timestamp(Statement command, DateTime value) throws Exception
		{
			value.setTimezoneOffset(0);
			StringBuffer s = new StringBuffer();
			s.append(value.toDateString(false));
			s.append(" ");
			s.append(value.toTimeString());
			command.bindParameter(java.sql.Timestamp.valueOf(s.toString()));		
		}
	}

	public static class Progress
	{
		public static void bindParameter_TimestampTZ(Statement command, DateTime value) throws Exception
		{
			StringBuffer s = new StringBuffer();
			s.append( value.toDateString() );
			s.append(" ");
			s.append( value.toTimeString() );
			command.bindParameter(s.toString());
		}


		public static void read_TimestampTZ(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object obj = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}

			DateTime value = new DateTime();
			java.lang.String s = obj.toString(); 
			java.lang.String[] part1 = s.split(" ");
			java.lang.String datePart = part1[0];
			java.lang.String timePart = part1[1];
			java.lang.String zonePart = part1[2]+part1[3];
			java.lang.String[] part2 = timePart.split(":");
			java.lang.String hourPart = part2[0];
			java.lang.String minutePart = part2[1];
			java.lang.String secondPart = part2[2];
			java.lang.String fractionPart = part2.length >= 4 ? part2[3] : "0";
			timePart = hourPart + ":" + minutePart + ":" + secondPart + "." + fractionPart;
			s = datePart + "T" + timePart + zonePart;
			value.parseDateTime(s, DateTime.DateTimePart_Date | DateTime.DateTimePart_Time);
			record.fields.put(name, new MFSingletonSequence(value));
		}
	}

	public static class Access
	{
	}

	public static class Teradata
	{
		public static void read_Clob(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.io.Reader reader = recordset.getResultSet().getCharacterStream(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			StringBuilder sb = new StringBuilder();
			
			int charsRead;
			char[] buffer = new char[8 * 1024];
			while ((charsRead = reader.read(buffer, 0, buffer.length)) != -1)
				sb.append(buffer, 0, charsRead);
			
			reader.close();
			record.fields.put(name, new MFSingletonSequence(sb.toString()));
		}
		
		public static void read_Json(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Clob(record, recordset, name, column);
		}
		
		public static void read_Xml(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Clob(record, recordset, name, column);
		}
		
		public static void read_Udt(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			switch(recordset.getResultSet().getMetaData().getColumnType(column+1)){
			case java.sql.Types.CLOB:
			case java.sql.Types.NCLOB:
			case java.sql.Types.SQLXML:
				read_Clob(record, recordset, name, column);	
				break;
			case java.sql.Types.CHAR:
			case java.sql.Types.VARCHAR:
			case java.sql.Types.LONGVARCHAR:
			case java.sql.Types.NCHAR:
			case java.sql.Types.NVARCHAR:
			case java.sql.Types.LONGNVARCHAR:
			default:
				read_String(record, recordset, name, column);
				break;
			}
		}
		
		public static void read_Time(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.sql.Timestamp value = recordset.getResultSet().getTimestamp(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			DateTime dt = new DateTime();
			int local = java.util.TimeZone.getDefault().getOffset(value.getTime());
			dt.setTimeFromTimeValue(value.getTime()+local);
			dt.setPartSecond(value.getNanos() / 1000000000.0);
			record.fields.put(name, new MFSingletonSequence(dt));
		}
		
		public static void read_TimeWithTimezone(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.util.Calendar cal = java.util.Calendar.getInstance();
			java.sql.Timestamp time = recordset.getResultSet().getTimestamp(column+1, cal);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			java.util.TimeZone tz = cal.getTimeZone();
			int offset = tz.getOffset(time.getTime());
			int local = java.util.TimeZone.getDefault().getOffset(time.getTime());
			
			DateTime value = new DateTime(1,1,1);
			value.setTimeFromTimeValue(time.getTime()+local);
			value.setPartSecond(time.getNanos() / 1000000000.0);
			value.setTimezoneOffset(offset/60000);
			value.setHasTimezone(DateTime.TZ_OFFSET);
			record.fields.put(name, new MFSingletonSequence(value));
		}
		
		public static void read_TimestampWithTimezone(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			java.util.Calendar cal = java.util.Calendar.getInstance();
			java.sql.Timestamp timestamp = recordset.getResultSet().getTimestamp(column+1, cal);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			java.util.TimeZone tz = cal.getTimeZone();
			int offset = tz.getOffset(timestamp.getTime());
			DateTime value = timestampToDateTime(timestamp);
			value.setTimezoneOffset(offset/60000);
			value.setHasTimezone(DateTime.TZ_OFFSET);
			record.fields.put(name, new MFSingletonSequence(value));
		}


		public static final int DurationPart_Year = 1 << 0;
		public static final int DurationPart_Month = 1 << 1;
		public static final int DurationPart_Day = 1 << 2;
		public static final int DurationPart_Hour = 1 << 3;
		public static final int DurationPart_Minute = 1 << 4;
		public static final int DurationPart_Second = 1 << 5;
		public static final int DurationPart_Fraction = 1 << 6;

		public static Duration parseInterval(String str, int parts) throws Exception
		{
			Duration.RefInt n = new Duration.RefInt(0); 
			str = str.trim(); // strip leading/trailing whitespaces
			CalendarBase.ParseContext context = new Duration.ParseContext(str);
			String err = str + " cannot be converted to a duration value.";

			int years = 0;
			int months = 0;
			int days = 0;
			int hours = 0;
			int minutes = 0;
			int seconds = 0;
			double fraction = 0.0;
			
			boolean positive = true; // parse sign
			if( context.checkAndAdvance('-') ) positive = false;
			else if( context.checkAndAdvance('+') ) positive = true;
			if (!context.isValid()) throw new StringParseException(err,2);
			
			if( (parts & DurationPart_Year) == DurationPart_Year )
			{// parse year component
				while(context.readDigitAndAdvance(n, 1, 9)) { years = (years * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Year) == DurationPart_Year) 
			&& ((parts & DurationPart_Month) == DurationPart_Month) )
			{// check day-time divider
				if (!context.checkAndAdvance('-')) throw new StringParseException(err,2);
				if (!context.isValid()) throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Month) == DurationPart_Month )
			{// parse month component
				while(context.readDigitAndAdvance(n, 1, 9)) { months = (months * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Month) == DurationPart_Month) 
			&& ((parts & DurationPart_Day) == DurationPart_Day) )
			{// error: there is no interval that could combine ym and ds intervals 
				throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Day) == DurationPart_Day )
			{// parse day component
				while(context.readDigitAndAdvance(n, 1, 9)) { days = (days * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Day) == DurationPart_Day) 
			&& ((parts & DurationPart_Hour) == DurationPart_Hour) )
			{// check day-time divider
				if (!context.checkAndAdvance(' ')) throw new StringParseException(err,2);
				if (!context.isValid()) throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Hour) == DurationPart_Hour )
			{// parse hour component
				while(context.readDigitAndAdvance(n, 1, 9)) { hours = (hours * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Hour) == DurationPart_Hour) 
			&& ((parts & DurationPart_Minute) == DurationPart_Minute) )
			{// check hour-minute divider
				if (!context.checkAndAdvance(':')) throw new StringParseException(err,2);
				if (!context.isValid()) throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Minute) == DurationPart_Minute )
			{// parse minute component
				while(context.readDigitAndAdvance(n, 1, 9)) { minutes = (minutes * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Minute) == DurationPart_Minute) 
			&& ((parts & DurationPart_Second) == DurationPart_Second) )
			{// check minute-second divider
				if (!context.checkAndAdvance(':')) throw new StringParseException(err,2);
				if (!context.isValid()) throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Second) == DurationPart_Second )
			{// parse second component
				while(context.readDigitAndAdvance(n, 1, 9)) { seconds = (seconds * 10) + n.value; n.value = 0; }
			}
			
			if(((parts & DurationPart_Second) == DurationPart_Second) 
			&& ((parts & DurationPart_Fraction) == DurationPart_Fraction) )
			{// check second-fraction divider
				if (!context.checkAndAdvance('.')) throw new StringParseException(err,2);
				if (!context.isValid()) throw new StringParseException(err,2);
			}
			
			if( (parts & DurationPart_Fraction) == DurationPart_Fraction)
			{// parse fraction component
				int intval = 0;
				int digits = 0;
				while(context.readDigitAndAdvance(n, 1, 9)) { intval = (intval * 10) + n.value; n.value = 0; ++digits; }
				fraction = intval / Math.pow( 10, digits );
			}
			
			if((parts & (DurationPart_Year|DurationPart_Month)) > 0)
			{
				return new Duration( years, months, 0, 0, 0, 0, 0.0, !positive );
			}
			else if((parts & (DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction)) > 0)
			{
				return new Duration( 0, 0, days, hours, minutes, seconds, fraction, !positive );
			}
			else
			{
				throw new com.altova.AltovaException("Invalid field specification during interval parsing");
			}
		}
		
		public static void parseInterval(Record record, ResultSetWrapper recordset, String name, int column, int parts) throws Exception
		{
			String value = recordset.getResultSet().getString(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}

			Duration duration = parseInterval(value, parts);
			record.fields.put(name, new MFSingletonSequence(duration));
		}

		public static void read_IntervalYear(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Year);
		}
		public static void read_IntervalYearToMonth(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Year|DurationPart_Month);
		}
		public static void read_IntervalMonth(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Month);
		}
		public static void read_IntervalDay(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Day);
		}
		public static void read_IntervalDayToHour(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Day|DurationPart_Hour);
		}
		public static void read_IntervalDayToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
		}
		public static void read_IntervalDayToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_IntervalHour(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Hour);
		}
		public static void read_IntervalHourToMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute);
		}
		public static void read_IntervalHourToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_IntervalMinute(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Minute);
		}
		public static void read_IntervalMinuteToSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void read_IntervalSecond(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			parseInterval(record, recordset, name, column, DurationPart_Second|DurationPart_Fraction);
		}
		
		private static String periodPartToString( Object value ) throws Exception
		{
			if(value instanceof java.lang.Integer){
				long code = ((java.lang.Integer)value).longValue();
				long y, m, d;
				y = code / 10000;
				y -= (code < 0 ? 1 : 0);
				code -= y * 10000;
				y += 1900;
				m = code / 100;
				code -= m * 100;
				d = code;
				return (new DateTime((int)y,(int)m,(int)d)).toDateString();
			}
			if(value instanceof java.sql.Date){
				return timestampToDateTime((java.sql.Date)value).toDateString();
			}
			if(value instanceof java.sql.Time){
				return timestampToDateTime((java.sql.Time)value).toTimeString("0.000000###");
			}
			if(value instanceof java.sql.Timestamp){
				java.sql.Timestamp ts = (java.sql.Timestamp)value;
				com.altova.types.DateTime dt = timestampToDateTime(ts);
				return dt.toDateString() + " " + dt.toTimeString("0.000000###");
			}
			return value.toString();
		}

		private static Object[] periodParts( java.sql.Struct struct ) throws Exception
		{
			if(struct.getClass().getName().equals("com.teradata.jdbc.ResultStruct"))
			{
				java.lang.reflect.Method m = struct.getClass().getMethod("getMutableAttributeValueArray", (Class<?>[])(null));
				Object[] objects = (Object[])(m.invoke(struct, (Object[])(null)));
				return objects;
			}
			return struct.getAttributes();
		}
		
		private static String periodToString( java.sql.Struct struct ) throws Exception
		{
			Object[] parts = periodParts( struct );
			StringBuilder sb = new StringBuilder();
			sb.append("(");
			sb.append(periodPartToString(parts[0]));
			sb.append(", ");
			sb.append(periodPartToString(parts[1]));
			sb.append(")");
			return sb.toString();
		}
		
		private static void read_Period(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			Object value = recordset.getResultSet().getObject(column+1);
			
			if (recordset.getResultSet().wasNull())
			{
				record.fields.put(name, new MFEmptySequence());
				return;
			}
			
			if( value instanceof  java.sql.Struct ) {// normally an instance of com.teradata.jdbc.ResultStruct
				record.fields.put(name, new MFSingletonSequence(periodToString( (java.sql.Struct)value )));
				return;
			}
			
			record.fields.put(name, new MFSingletonSequence(value.toString()));
		}

		public static void read_PeriodDate(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Period(record, recordset, name, column);
		}

		public static void read_PeriodTime(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Period(record, recordset, name, column);
		}

		public static void read_PeriodTimeWithTimezone(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Period(record, recordset, name, column);
		}

		public static void read_PeriodTimestamp(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Period(record, recordset, name, column);
		}

		public static void read_PeriodTimestampWithTimezone(Record record, ResultSetWrapper recordset, String name, int column) throws Exception
		{
			read_Period(record, recordset, name, column);
		}
		
		
		public static void bindParameter_Interval(Statement command, Duration duration, int parts) throws Exception
		{
			DecimalFormatSymbols symbols = new DecimalFormatSymbols(java.util.Locale.US);
			DecimalFormat formatter2 = new DecimalFormat("00", symbols);
			DecimalFormat formatter4 = new DecimalFormat("0000", symbols);

			StringBuilder s = new StringBuilder();
			if (duration.isNegative())
				s.append("-");

			if( (parts & (DurationPart_Year|DurationPart_Month)) > 0)
			{// process: interval year month
				
				int years = java.lang.Math.abs(duration.getYear());
				int months = java.lang.Math.abs(duration.getMonth());
						
				if( (parts & DurationPart_Year) == DurationPart_Year )
					s.append(formatter4.format(years));
				
				if(((parts & DurationPart_Year) == DurationPart_Year) && ((parts & DurationPart_Month) == DurationPart_Month) )
					s.append("-");
	
				if( (parts & DurationPart_Month) == DurationPart_Month )
					if( (parts & DurationPart_Year) == DurationPart_Year )
						s.append(formatter2.format(months));
					else 
						s.append(formatter2.format(years*12 + months));
			}
			
			if(((parts & DurationPart_Month) == DurationPart_Month) && ((parts & DurationPart_Day) == DurationPart_Day) )
				throw new com.altova.AltovaException("Invalid field specification during interval conversion");
			
			if( (parts & (DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction)) > 0)
			{// process: interval day to second
				
				int days = java.lang.Math.abs(duration.getDay());
				int hours = java.lang.Math.abs(duration.getHour());
				int minutes = java.lang.Math.abs(duration.getMinute());
				int seconds = java.lang.Math.abs(duration.getSecond());
				
				if( (parts & DurationPart_Day) == DurationPart_Day )
					s.append(formatter2.format(days));
				
				if(((parts & DurationPart_Day) == DurationPart_Day) && ((parts & DurationPart_Hour) == DurationPart_Hour) )
					s.append(" ");
				
				if( (parts & DurationPart_Hour) == DurationPart_Hour )
					if((parts & DurationPart_Day) == DurationPart_Day)
						s.append(formatter2.format(hours));
					else
						s.append(formatter2.format(days*24 + hours));
	
				if(((parts & DurationPart_Hour) == DurationPart_Hour) && ((parts & DurationPart_Minute) == DurationPart_Minute) )
					s.append(":");
				
				if( (parts & DurationPart_Minute) == DurationPart_Minute )
					if((parts & DurationPart_Hour) == DurationPart_Hour)
						s.append(formatter2.format(minutes));
					else 
						s.append(formatter2.format((days*24*60) + (hours*60) + minutes));
				
				if(((parts & DurationPart_Minute) == DurationPart_Minute) && ((parts & DurationPart_Second) == DurationPart_Second) )
					s.append(":");
				
				if( (parts & (DurationPart_Second)) == (DurationPart_Second) )
					if( (parts & DurationPart_Minute) == DurationPart_Minute )
						s.append(formatter2.format(seconds));
					else
						s.append(formatter2.format((days*24*60*60) + (hours*60*60) + (minutes*60) + seconds));
				 
				if( (parts & (DurationPart_Fraction)) == (DurationPart_Fraction) ) {
					double fraction = java.lang.Math.abs(duration.getPartSecond());
					DecimalFormat formatter = new DecimalFormat("0.0#####", symbols);
					s.append(formatter.format(fraction).substring(1));
				}			
			}
		
			command.bindParameter(s.toString());
		}

		public static void bindParameter_IntervalYear(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Year);
		}
		public static void bindParameter_IntervalYearToMonth(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Year|DurationPart_Month);
		}
		public static void bindParameter_IntervalMonth(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Month);
		}		
		public static void bindParameter_IntervalDay(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Day);
		}
		public static void bindParameter_IntervalDayToHour(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Day|DurationPart_Hour);
		}
		public static void bindParameter_IntervalDayToMinute(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Day|DurationPart_Hour|DurationPart_Minute);
		}
		public static void bindParameter_IntervalDayToSecond(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Day|DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalHour(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Hour);
		}
		public static void bindParameter_IntervalHourToMinute(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Hour|DurationPart_Minute);
		}
		public static void bindParameter_IntervalHourToSecond(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Hour|DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalMinute(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Minute);
		}
		public static void bindParameter_IntervalMinuteToSecond(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Minute|DurationPart_Second|DurationPart_Fraction);
		}
		public static void bindParameter_IntervalSecond(Statement command, Duration value) throws Exception
		{
			bindParameter_Interval(command, value, DurationPart_Second|DurationPart_Fraction);
		}

		public static void bindParameter_Time(Statement command, DateTime value) throws Exception
		{
			value.setHasTimezone(DateTime.TZ_MISSING);
			String time = value.toTimeString("0.0#####");
			command.bindParameter(time);
		}

		public static void bindParameter_TimeWithTimezone(Statement command, DateTime value) throws Exception
		{
			int offset = 0;
			if(!((value.hasTimezone()==DateTime.TZ_UTC) || (value.hasTimezone()==DateTime.TZ_OFFSET && value.getTimezoneOffset() == 0)))
				offset = value.getTimezoneOffset();// driver doesn't handle Zulu time zone as expected.
				
			value.setHasTimezone(DateTime.TZ_MISSING);
			String time = value.toTimeString("0.0#####");
			
			StringBuilder s = new StringBuilder();
			s.append((offset < 0) ? "-" : "+");
			s.append(new DecimalFormat("00", new DecimalFormatSymbols(java.util.Locale.US)).format(Math.abs(offset) / 60));
			s.append(":");
			s.append(new DecimalFormat("00", new DecimalFormatSymbols(java.util.Locale.US)).format(Math.abs(offset) % 60));
			String zone = s.toString();
			
			command.bindParameter(time+zone);
		}

		public static void bindParameter_TimestampWithTimezone(Statement command, DateTime value) throws Exception
		{
			int offset = 0;
			if(!((value.hasTimezone()==DateTime.TZ_UTC) || (value.hasTimezone()==DateTime.TZ_OFFSET && value.getTimezoneOffset() == 0)))
				offset = value.getTimezoneOffset();// driver doesn't handle Zulu time zone as expected.
				
			value.setHasTimezone(DateTime.TZ_MISSING);
			String date = value.toDateString(false);
			String time = value.toTimeString("0.0#####");

			StringBuilder s = new StringBuilder();
			s.append((offset < 0) ? "-" : "+");
		    s.append(new DecimalFormat("00", new DecimalFormatSymbols(java.util.Locale.US)).format(Math.abs(offset) / 60));
		    s.append(":");
		    s.append(new DecimalFormat("00", new DecimalFormatSymbols(java.util.Locale.US)).format(Math.abs(offset) % 60));
		    String zone = s.toString();
		    
			command.bindParameter(date + " " + time + zone);
		}

	}

}
