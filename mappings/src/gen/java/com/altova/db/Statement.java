/**
 * Statement.java
 *
 * This file was generated by MapForce 2010r3.
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the MapForce Documentation for further details.
 * http://www.altova.com/mapforce
 */


package com.altova.db;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.util.ArrayList;


public class Statement 
{
	static public class Parameter
	{
		public Parameter(int type) {this.type=type;}
		public Parameter(int type, int scaleOrLength) {this.type=type; this.scaleOrLength=scaleOrLength;}
		public int type;
		public int scaleOrLength = -1;
	}
	
	private java.sql.Statement statement=null;
	private Catalog catalog = null;
	private String	statement_string;
	private ArrayList<Parameter> parameters;
	private ArrayList<Object> values;

	public Statement(Catalog catalog, String newStatement) 
	{
		this.catalog = catalog;
		statement_string = newStatement;
		parameters = new ArrayList<Parameter>();
		values = new ArrayList<Object>();
	}

	public String getStatement() 
	{
		return statement_string;
	}
			
	public void setStatement(String newValue) 
	{
		statement_string = newValue;
	}

	public Connection getConnection() 
	{
		return catalog.getConnection();
	}

	private boolean usePrepare() throws Exception
	{
		if( statement instanceof PreparedStatement )
			return true;

		if( parameters.isEmpty() && !( statement_string.startsWith("SELECT") ) ) 
			return false;
		
		return true;
	}

	public void prepare() throws Exception
	{
		if( usePrepare() )
			statement = catalog.getConnection().prepareStatement(statement_string);
		else
			statement = catalog.getConnection().createStatement();

		try { statement.setQueryTimeout( catalog.getQueryTimeout() ); }
		catch( java.sql.SQLException ex )// e.g. for JdbcOdbc
		{// ignore error: S1C00 - Optional feature not implemented
		//  ignore error: 0A000 - setQueryTimeout(int) is not yet implemented.
			if(!((ex.getSQLState().equals("S1C00"))||(ex.getSQLState().equals("0A000"))))
				throw ex; 
		}
	}

	public void addParameter(int type)	
	{
		parameters.add(new Parameter(type));
	}
	
	public void addParameter(int type, int scaleOrLength)	
	{
		parameters.add(new Parameter(type, scaleOrLength));
	}
	
	public Parameter getParameter(int i)	
	{
		return (i >=0 && i < parameters.size())
				? parameters.get(i) : null;
	}

	public void setParameterType(int i, int type)	
	{
		Parameter p = parameters.get(i);
		p.type = type;
		parameters.set(i, p);
	}

	public ArrayList<Object> getValues()
	{
		return values;
	}
	
	public void bindParameter(Object value, int scale)
	{
		values.add(value);
		int i = values.size()-1;
		Parameter p = parameters.get(i);
		p.scaleOrLength = scale;
		parameters.set(i, p);
	}
	
	public void bindParameter(Object value)
	{
		values.add(value);
	}
	
	public void clear()
	{
		values.clear();
	}
	
	private void preExecute() throws Exception
	{
		if( statement == null )
			prepare();

		for (int i = 0; i < parameters.size(); i++)
		{
			PreparedStatement prepared = (PreparedStatement)(statement);
			try 
			{
				if (values.get(i) == null)
					prepared.setNull(i+1, parameters.get(i).type);	
				else if( (values.get(i) instanceof java.sql.Time) && (parameters.get(i).type == java.sql.Types.TIME) )
					prepared.setTime(i+1, (java.sql.Time)(values.get(i)));
				else if( (values.get(i) instanceof java.io.ByteArrayInputStream) && (parameters.get(i).type == java.sql.Types.BINARY) )
					prepared.setBinaryStream(i+1, (java.io.InputStream)(values.get(i)), ((java.io.InputStream)(values.get(i))).available() );
				else
				{
					if (parameters.get(i).scaleOrLength < 0)
						prepared.setObject(i+1, values.get(i), parameters.get(i).type);
					else
						prepared.setObject(i+1, values.get(i), parameters.get(i).type, parameters.get(i).scaleOrLength);
				}
			}
			catch (java.sql.SQLException e)
			{
				if (values.get(i) instanceof java.math.BigInteger)
				{
					java.math.BigInteger v = (java.math.BigInteger)values.get(i);
					
					if (parameters.get(i).type == java.sql.Types.TINYINT && prepared.getMetaData().isSigned(i+1))
						prepared.setObject(i+1, Long.valueOf(v.longValue()), java.sql.Types.SMALLINT);
					else
					{
						if (parameters.get(i).scaleOrLength < 0)
							prepared.setObject(i+1, Long.valueOf(v.longValue()), parameters.get(i).type);
						else
							prepared.setObject(i+1, Long.valueOf(v.longValue()), parameters.get(i).type, parameters.get(i).scaleOrLength);					
					}
				}
				else
					throw e;
			}
		}
	}

	public ResultSetWrapper execute() throws Exception
	{
		preExecute();

		boolean isResult = false;
		if( statement instanceof PreparedStatement )
			isResult = ((PreparedStatement)(statement)).execute();
		else 
			isResult = statement.execute(statement_string);
		
		while (!isResult)
			isResult = statement.getMoreResults();
		
		return new ResultSetWrapper(catalog, statement.getResultSet(), this);
	}

	public int executeNonReader() throws Exception
	{
		int result = 0;
		
		preExecute();
		try 
		{ 
			if( statement instanceof PreparedStatement )
				result = ((PreparedStatement)(statement)).executeUpdate();
			else
				result = statement.executeUpdate(statement_string);
		}
		catch( java.sql.SQLException e ) 
		{
			if( !e.getMessage().equalsIgnoreCase("no data found") )
				throw e;
		}
		finally
		{
			if(Dbs.checkForJdbcOdbcConnection(statement.getConnection()))
				destroy();
			else if(statement.getClass().getName().startsWith("com.teradata.jdbc"))
				destroy();
		}
		
		return result;
	}

	public void close() throws Exception 
	{
		clear();
	}
	
	public void destroy() throws Exception 
	{
		clear();
		if (statement != null) {
			statement.close();
			statement = null;
		}
	}
}
